<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Logic Studio Pro</title>
    <style>
        :root {
            --primary: #2c3e50;
            --accent: #3498db;
            --bg: #f0f2f5;
            --panel: #ffffff;
            --border: #e1e4e8;
            --text: #333;
            --success-bg: #d4edda;
            --header-bg: #f8f9fa;
        }

        * { box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg);
            margin: 0;
            padding: 10px;
            color: var(--text);
            display: flex;
            justify-content: center;
        }

        .container {
            width: 100%;
            max-width: 1200px; /* Limits max width on desktop */
            background: var(--panel);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            /* Critical: prevents container from growing wider than screen */
            min-width: 0; 
        }

        h1 {
            color: var(--primary);
            margin: 0 0 20px 0;
            font-size: 1.5rem;
            border-bottom: 3px solid var(--accent);
            display: inline-block;
            padding-bottom: 5px;
        }

        /* --- ACCORDION --- */
        .accordion { margin-bottom: 20px; border: 1px solid var(--border); border-radius: 8px; overflow: hidden; }
        .accordion-item { border-bottom: 1px solid var(--border); }
        .accordion-item:last-child { border-bottom: none; }
        
        .accordion-header {
            background: var(--header-bg);
            padding: 15px;
            cursor: pointer;
            font-weight: 600;
            color: var(--primary);
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
            font-size: 0.95rem;
        }
        
        .accordion-header::after { content: '+'; font-size: 1.2rem; color: var(--accent); font-weight: bold; }
        .accordion-item.active .accordion-header::after { content: '‚àí'; }
        
        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s cubic-bezier(0, 1, 0, 1);
            background: #fff;
        }
        
        .accordion-item.active .accordion-content { max-height: 1000px; transition: max-height 0.3s ease-in-out; }
        
        .accordion-body { padding: 15px; line-height: 1.6; font-size: 0.9rem; color: #555; }
        .accordion-body ul, .accordion-body ol { margin: 0; padding-left: 20px; }
        .accordion-body li { margin-bottom: 5px; }

        /* Chips */
        .chip-container { display: flex; flex-wrap: wrap; gap: 8px; }
        .chip { 
            background: #edf2f7; border: 1px solid #cad5de; padding: 4px 10px; 
            border-radius: 15px; cursor: pointer; font-family: monospace; 
            font-size: 0.85rem; color: var(--accent); 
        }
        .chip:hover { background: var(--accent); color: white; }

        /* --- INPUT AREA --- */
        .input-group { display: flex; flex-direction: column; gap: 10px; margin-bottom: 20px; }
        @media(min-width: 600px) { .input-group { flex-direction: row; } }
        
        input[type="text"] {
            flex-grow: 1; padding: 12px; font-size: 1rem;
            border: 2px solid var(--border); border-radius: 6px;
            font-family: 'Courier New', monospace;
        }
        input[type="text"]:focus { outline: none; border-color: var(--accent); }
        
        button.btn-analyze {
            background-color: var(--accent); color: white; border: none;
            padding: 12px 25px; font-size: 1rem; font-weight: bold;
            border-radius: 6px; cursor: pointer;
        }
        
        /* --- SCROLLABLE WRAPPERS (The Layout Fix) --- */
        .scroll-wrapper {
            width: 100%;
            overflow: auto; /* Handles both X and Y scrolling */
            border: 1px solid var(--border);
            border-radius: 6px;
            background: #fff;
            margin-bottom: 0; /* Reset */
            -webkit-overflow-scrolling: touch; /* Smooth scroll on iOS */
        }

        /* --- CIRCUIT SVG --- */
        #circuit-container {
            height: 400px; /* Fixed height window */
            min-width: 600px; /* Ensures SVG doesn't crunch */
            display: block;
        }
        svg { display: block; margin: 0 auto; }
        
        /* SVG Elements */
        .gate-body { fill: #fff; stroke: #333; stroke-width: 2px; }
        .gate-bubble { fill: #fff; stroke: #333; stroke-width: 2px; }
        .wire { stroke: #333; stroke-width: 2px; fill: none; }
        .rail-line { stroke: #bdc3c7; stroke-width: 2px; stroke-dasharray: 4; }
        .dot { fill: #333; }
        .txt { font-family: sans-serif; font-weight: bold; fill: var(--primary); }

        /* --- TRUTH TABLE --- */
        .output-section { display: grid; grid-template-columns: 1fr; gap: 20px; }
        @media(min-width: 1000px) { .output-section { grid-template-columns: 2fr 1fr; } }

        .section-title { font-size: 0.9rem; text-transform: uppercase; color: #888; margin-bottom: 8px; font-weight: bold; letter-spacing: 0.5px; }

        table { border-collapse: collapse; font-family: 'Courier New', monospace; font-size: 0.85rem; width: 100%; }
        th, td { padding: 8px 12px; text-align: center; border-bottom: 1px solid #eee; border-right: 1px solid #eee; white-space: nowrap; }
        th { background: #f8f9fa; position: sticky; top: 0; border-bottom: 2px solid #ddd; font-weight: bold; }
        tr.active-row { background-color: var(--success-bg); font-weight: bold; color: #155724; }
        
        /* Highlight Intermediate Columns slightly differently */
        th.col-inter { color: #666; font-weight: normal; font-size: 0.8em; }
        th.col-final { color: var(--accent); font-size: 1.1em; }
        
        .error { color: #e74c3c; font-weight: bold; margin-bottom: 10px; display: none; }
    </style>
</head>
<body>

<div class="container">
    <h1>Logic Studio</h1>

    <!-- ACCORDION -->
    <div class="accordion">
        
        <!-- 1. Guide -->
        <div class="accordion-item">
            <div class="accordion-header">üìñ Syntax Guide</div>
            <div class="accordion-content">
                <div class="accordion-body">
                    <strong>AND:</strong> <code>AB</code>, <code>A*B</code><br>
                    <strong>OR:</strong> <code>A+B</code><br>
                    <strong>NOT:</strong> <code>!A</code>, <code>A'</code><br>
                    <strong>Grouping:</strong> <code>(A+B)C</code>
                </div>
            </div>
        </div>

        <!-- 2. Manual Solving Steps (New) -->
        <div class="accordion-item">
            <div class="accordion-header">üìù How to Solve Manually</div>
            <div class="accordion-content">
                <div class="accordion-body">
                    <ol>
                        <li><strong>Order of Precedence:</strong> Solve <strong>NOT</strong> first, then <strong>AND</strong>, then <strong>OR</strong>. Anything in <code>( )</code> happens first.</li>
                        <li><strong>Identify Columns:</strong> Create columns for Inputs (A, B...), then columns for every small operation (e.g., A', B+C).</li>
                        <li><strong>Binary Counting:</strong> Fill Input columns counting from 0 to 2^n - 1 (e.g., 00, 01, 10, 11).</li>
                        <li><strong>Compute Steps:</strong> Fill the intermediate columns row by row.</li>
                        <li><strong>Final Result:</strong> Combine the intermediate results to get the Final Output (Q).</li>
                    </ol>
                </div>
            </div>
        </div>

        <!-- 3. Predefined -->
        <div class="accordion-item">
            <div class="accordion-header">‚ö° Predefined Functions</div>
            <div class="accordion-content">
                <div class="accordion-body">
                    <div class="chip-container">
                        <div class="chip" onclick="setInput('A(B+C\')')">Complex Mix</div>
                        <div class="chip" onclick="setInput('!(AB)')">De Morgan (NAND)</div>
                        <div class="chip" onclick="setInput('AB + !A!B')">XNOR</div>
                        <div class="chip" onclick="setInput('Cin(A+B) + AB')">Full Adder Carry</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- CONTROL -->
    <div class="input-group">
        <input type="text" id="expression" placeholder="e.g. A(B+C')" value="A(B+C')">
        <button class="btn-analyze" onclick="runAnalysis()">Analyze</button>
    </div>
    <div id="error-msg" class="error"></div>

    <!-- OUTPUTS -->
    <div class="output-section">
        
        <!-- Diagram -->
        <div>
            <div class="section-title">Circuit Diagram</div>
            <div class="scroll-wrapper">
                <div id="circuit-container">
                    <!-- SVG Injected Here -->
                </div>
            </div>
        </div>

        <!-- Table -->
        <div>
            <div class="section-title">Truth Table (With Steps)</div>
            <div class="scroll-wrapper" style="max-height: 400px;">
                <div id="table-container">
                    <!-- Table Injected Here -->
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    // --- ACCORDION LOGIC (Exclusive Opening) ---
    const accHeaders = document.querySelectorAll('.accordion-header');
    
    accHeaders.forEach(header => {
        header.addEventListener('click', () => {
            const currentItem = header.parentElement;
            const isActive = currentItem.classList.contains('active');
            
            // Close all
            document.querySelectorAll('.accordion-item').forEach(item => {
                item.classList.remove('active');
            });

            // If it wasn't active before, open it now
            if (!isActive) {
                currentItem.classList.add('active');
            }
        });
    });

    function setInput(val) {
        document.getElementById('expression').value = val;
        runAnalysis();
    }

    // --- LOGIC ENGINE ---

    const TYPE = { VAR: 'VAR', AND: 'AND', OR: 'OR', NOT: 'NOT', LPAREN: 'LPAREN', RPAREN: 'RPAREN' };

    function tokenize(str) {
        let raw = [];
        str = str.replace(/\s+/g, '');
        let i = 0;
        while(i < str.length) {
            let c = str[i];
            if(/[a-zA-Z]/.test(c)) raw.push({type:TYPE.VAR, value:c});
            else if(c === '+' || c === '|') raw.push({type:TYPE.OR});
            else if(c === '*' || c === '&') raw.push({type:TYPE.AND});
            else if(c === '!' || c === '~') raw.push({type:TYPE.NOT, sub:'PRE'});
            else if(c === "'") raw.push({type:TYPE.NOT, sub:'POST'});
            else if(c === '(') raw.push({type:TYPE.LPAREN});
            else if(c === ')') raw.push({type:TYPE.RPAREN});
            i++;
        }
        
        let tokens = [];
        for(let j=0; j<raw.length; j++) {
            tokens.push(raw[j]);
            if(j < raw.length-1) {
                let c = raw[j], n = raw[j+1];
                let endT = (c.type === TYPE.VAR || c.type === TYPE.RPAREN || (c.type === TYPE.NOT && c.sub === 'POST'));
                let startT = (n.type === TYPE.VAR || n.type === TYPE.LPAREN || (n.type === TYPE.NOT && n.sub === 'PRE'));
                if(endT && startT) tokens.push({type:TYPE.AND});
            }
        }
        return tokens;
    }

    class Parser {
        constructor(tokens) { this.tokens = tokens; this.pos = 0; }
        peek() { return this.tokens[this.pos]; }
        consume() { return this.tokens[this.pos++]; }
        isAtEnd() { return this.pos >= this.tokens.length; }
        parse() { return this.expr(); }
        
        expr() {
            let left = this.term();
            while(!this.isAtEnd() && this.peek().type === TYPE.OR) {
                this.consume();
                let right = this.term();
                left = { type: 'OR', children: [left, right], id: Math.random() };
            }
            return left;
        }
        term() {
            let left = this.factor();
            while(!this.isAtEnd() && this.peek().type === TYPE.AND) {
                this.consume();
                let right = this.factor();
                left = { type: 'AND', children: [left, right], id: Math.random() };
            }
            return left;
        }
        factor() {
            if(this.peek().type === TYPE.NOT && this.peek().sub === 'PRE') {
                this.consume();
                return { type: 'NOT', children: [this.factor()], id: Math.random() };
            }
            let node = this.primary();
            while(!this.isAtEnd() && this.peek().type === TYPE.NOT && this.peek().sub === 'POST') {
                this.consume();
                node = { type: 'NOT', children: [node], id: Math.random() };
            }
            return node;
        }
        primary() {
            let t = this.peek();
            if(t.type === TYPE.VAR) { this.consume(); return { type: 'VAR', value: t.value, children: [] }; }
            if(t.type === TYPE.LPAREN) {
                this.consume();
                let e = this.expr();
                this.consume();
                return e;
            }
            throw new Error("Syntax Error");
        }
    }

    // --- INTERMEDIATE STEP GENERATOR ---

    // 1. Convert AST Node to String (e.g., "A+B")
    function nodeToString(node) {
        if(node.type === 'VAR') return node.value;
        if(node.type === 'NOT') {
            let childStr = nodeToString(node.children[0]);
            // If child is an operation, wrap in parens for clarity
            if(node.children[0].children.length > 0) childStr = `(${childStr})`;
            return `${childStr}'`;
        }
        if(node.type === 'AND' || node.type === 'OR') {
            let op = node.type === 'AND' ? '' : '+';
            let l = nodeToString(node.children[0]);
            let r = nodeToString(node.children[1]);
            // Add parens if child is OR and we are ANDing
            if(node.type === 'AND' && node.children[0].type === 'OR') l = `(${l})`;
            if(node.type === 'AND' && node.children[1].type === 'OR') r = `(${r})`;
            return `${l}${op}${r}`;
        }
    }

    // 2. Collect all sub-expressions (nodes) in post-order
    function collectSteps(node, map) {
        if(!node) return;
        node.children.forEach(c => collectSteps(c, map));
        
        // Only collect operations, not raw variables
        if(node.type !== 'VAR') {
            let str = nodeToString(node);
            // Map keys ensure uniqueness
            map.set(str, node); 
        }
    }

    // 3. Evaluate specific node
    function evalNode(node, context) {
        if(node.type === 'VAR') return context[node.value];
        if(node.type === 'NOT') return evalNode(node.children[0], context) ? 0 : 1;
        if(node.type === 'AND') return (evalNode(node.children[0], context) && evalNode(node.children[1], context)) ? 1 : 0;
        if(node.type === 'OR') return (evalNode(node.children[0], context) || evalNode(node.children[1], context)) ? 1 : 0;
        return 0;
    }

    function generateTruthTable(ast, vars) {
        // Collect intermediate steps
        let stepsMap = new Map();
        collectSteps(ast, stepsMap);
        
        // Remove the final root expression from steps if it's there (we show it as Q)
        let rootStr = nodeToString(ast);
        // We will treat the last item as Output Q, but let's keep intermediate ones
        // Convert map to array
        let steps = Array.from(stepsMap.keys());
        // Filter out the full expression to avoid duplicate column "Q vs Expression"
        steps = steps.filter(s => s !== rootStr);

        let html = '<table><thead><tr>';
        
        // Headers: Vars -> Intermediates -> Output
        vars.forEach(v => html += `<th>${v}</th>`);
        steps.forEach(s => html += `<th class="col-inter">${s}</th>`);
        html += '<th class="col-final">Q</th></tr></thead><tbody>';

        const rows = Math.pow(2, vars.length);
        
        for(let i=0; i<rows; i++) {
            let ctx = {};
            let rowHtml = '';
            
            // 1. Inputs
            for(let j=0; j<vars.length; j++) {
                let bit = (i >> (vars.length - 1 - j)) & 1;
                ctx[vars[j]] = bit;
                rowHtml += `<td>${bit}</td>`;
            }

            // 2. Intermediates
            steps.forEach(s => {
                let node = stepsMap.get(s);
                rowHtml += `<td>${evalNode(node, ctx)}</td>`;
            });

            // 3. Final Output
            let res = evalNode(ast, ctx);
            let cls = res === 1 ? 'class="active-row"' : '';
            
            html += `<tr ${cls}>${rowHtml}<td>${res}</td></tr>`;
        }
        return html + '</tbody></table>';
    }

    // --- VISUALIZATION LAYOUT ---
    
    const CFG = { vGap: 60, hGap: 100, railStart: 30, railSpace: 25 };

    function calcSize(node) {
        if(!node.children.length) { node.hSize = 1; return 1; }
        let h = 0;
        node.children.forEach(c => h += calcSize(c));
        node.hSize = h;
        return h;
    }

    function assignPos(node, x, y) {
        node.x = x; node.y = y;
        if(!node.children.length) return;
        let startY = y - (node.hSize * CFG.vGap)/2;
        let curr = 0;
        node.children.forEach(c => {
            let cy = startY + (curr * CFG.vGap) + (c.hSize * CFG.vGap)/2;
            assignPos(c, x - CFG.hGap, cy);
            curr += c.hSize;
        });
    }

    function drawSystem(node, cmds, rails) {
        if(!node) return;
        node.children.forEach(c => drawSystem(c, cmds, rails));

        node.children.forEach((child, i) => {
            let sx, sy, ex, ey, isRail = false;
            ex = node.x - (node.type === 'NOT' ? 30 : 40);
            ey = node.y;
            if(node.children.length > 1) ey += (i===0 ? -10 : 10);

            if(child.type === 'VAR') {
                sx = rails[child.value]; sy = ey; isRail = true;
            } else {
                sx = child.x + (child.type === 'NOT'?4:5); sy = child.y;
            }

            if(isRail) {
                cmds.push(`<circle cx="${sx}" cy="${sy}" r="3" class="dot"/>`);
                cmds.push(`<line x1="${sx}" y1="${sy}" x2="${ex}" y2="${ey}" class="wire"/>`);
            } else {
                let cp = sx + (ex-sx)/2;
                cmds.push(`<path d="M${sx},${sy} C${cp},${sy} ${cp},${ey} ${ex},${ey}" class="wire"/>`);
            }
        });

        if(node.type !== 'VAR') {
            let gx=node.x, gy=node.y;
            let d = "";
            if(node.type==='AND') d=`M${gx-40},${gy-20} v40 h20 a20,20 0 0 0 0,-40 z`;
            else if(node.type==='OR') d=`M${gx-40},${gy-20} c0,0 10,0 15,20 c-5,20 -15,20 -15,20 h10 c20,0 30,-20 30,-20 c0,0 -10,-20 -30,-20 z`;
            else if(node.type==='NOT') d=`M${gx-30},${gy-15} v30 l25,-15 z`;
            
            cmds.push(`<path d="${d}" class="gate-body"/>`);
            if(node.type==='NOT') cmds.push(`<circle cx="${gx}" cy="${gy}" r="4" class="gate-bubble"/>`);
        }
    }

    function getVars(node, set) {
        if(node.type === 'VAR') set.add(node.value);
        node.children.forEach(c => getVars(c, set));
    }

    // --- MAIN RUNNER ---
    function runAnalysis() {
        const input = document.getElementById('expression').value;
        const errDiv = document.getElementById('error-msg');
        const cDiv = document.getElementById('circuit-container');
        const tDiv = document.getElementById('table-container');

        errDiv.style.display = 'none';
        cDiv.innerHTML = ''; tDiv.innerHTML = '';

        if(!input.trim()) return;

        try {
            // 1. Parse
            const tokens = tokenize(input);
            const parser = new Parser(tokens);
            const ast = parser.parse();

            // 2. Vars
            let varSet = new Set();
            getVars(ast, varSet);
            let sortedVars = Array.from(varSet).sort();

            // 3. Table (With Steps)
            tDiv.innerHTML = generateTruthTable(ast, sortedVars);

            // 4. Diagram
            calcSize(ast);
            const depth = (function d(n){ return !n.children.length?1:1+Math.max(...n.children.map(d))})(ast);
            
            const railWidth = CFG.railStart + (sortedVars.length * CFG.railSpace) + 30;
            const width = railWidth + (depth * CFG.hGap) + 80;
            const height = Math.max(380, ast.hSize * CFG.vGap + 80);

            assignPos(ast, width - 60, height/2);

            let cmds = [];
            let railMap = {};
            sortedVars.forEach((v, i) => {
                let rx = CFG.railStart + (i * CFG.railSpace);
                railMap[v] = rx;
                cmds.push(`<text x="${rx}" y="30" class="txt" text-anchor="middle">${v}</text>`);
                cmds.push(`<line x1="${rx}" y1="40" x2="${rx}" y2="${height-20}" class="rail-line"/>`);
            });

            drawSystem(ast, cmds, railMap);

            // Final Output Wire
            let ox = ast.x + (ast.type==='NOT'?4:5);
            cmds.push(`<line x1="${ox}" y1="${ast.y}" x2="${ox+40}" y2="${ast.y}" class="wire"/>`);
            cmds.push(`<text x="${ox+45}" y="${ast.y+5}" class="txt">Q</text>`);

            cDiv.innerHTML = `<svg width="${width}" height="${height}">${cmds.join('')}</svg>`;

        } catch(e) {
            console.error(e);
            errDiv.innerText = "Syntax Error: " + e.message;
            errDiv.style.display = 'block';
        }
    }

    window.onload = runAnalysis;

</script>
</body>
</html>