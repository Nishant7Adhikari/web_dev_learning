<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Space Fabric</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: #fff; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif; overscroll-behavior: none; display: flex; flex-direction: column; height: 100vh; }
        canvas { display: block; width: 100%; height: 100%; flex-grow: 1; }
        #info-overlay { position: absolute; top: 10px; left: 10px; padding: 8px 12px; background: rgba(0,0,0,0.6); border-radius: 8px; z-index: 10; font-size: 11px; max-width: calc(100vw - 20px); box-sizing: border-box; color: #ccc; }
        #hud { position: absolute; top: 10px; right: 10px; padding: 10px; background: rgba(0,0,0,0.6); border-radius: 8px; z-index: 10; font-size: 12px; color: #e0e0e0; text-align: right; min-width: 180px; }
        #hud div { margin-bottom: 4px; }
        #hud-obj-stats { font-size: 11px; color: #b0b0b0; border-top: 1px solid rgba(255,255,255,0.1); margin-top: 5px; padding-top: 5px; }
        #bottom-toolbar { position: fixed; bottom: 0; left: 0; right: 0; background-color: rgba(20, 20, 30, 0.85); backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px); display: flex; justify-content: space-around; align-items: center; padding: 8px 0; padding-bottom: calc(8px + env(safe-area-inset-bottom)); z-index: 100; border-top: 1px solid rgba(255,255,255,0.1); }
        #bottom-toolbar button { background: none; border: none; color: #b0c4de; font-size: 10px; padding: 5px; display: flex; flex-direction: column; align-items: center; cursor: pointer; min-width: 55px; text-align: center; transition: color 0.2s; }
        #bottom-toolbar button:hover { color: #ffffff; }
        #bottom-toolbar button:disabled { color: #506070; cursor: not-allowed; }
        #bottom-toolbar button svg { width: 22px; height: 22px; margin-bottom: 3px; fill: currentColor; }
        #bottom-toolbar button span { display: block; }
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); backdrop-filter: blur(2px); -webkit-backdrop-filter: blur(2px); z-index: 1000; justify-content: center; align-items: center; padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left); }
        .modal.active { display: flex; }
        .modal-content { background-color: rgba(35, 35, 50, 0.97); padding: 20px; border-radius: 10px; width: 90%; max-width: 380px; max-height: 80vh; overflow-y: auto; box-shadow: 0 4px 20px rgba(0,0,0,0.25); border: 1px solid rgba(255,255,255,0.08); }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid rgba(255,255,255,0.08); }
        .modal-header h3 { margin: 0; font-size: 17px; color: #e0e8ff; }
        .modal-close-btn { background: none; border: none; color: #99aacc; font-size: 22px; cursor: pointer; padding: 5px; line-height: 1; }
        .modal-body .form-group { margin-bottom: 12px; }
        .modal-body label { display: block; margin-bottom: 4px; font-size: 12px; color: #b0c0d0; }
        .modal-body input[type="text"], .modal-body input[type="number"], .modal-body input[type="color"], .modal-body select { width: calc(100% - 18px); padding: 9px; border: 1px solid #4a5568; background-color: #202530; color: #ddeeff; border-radius: 5px; font-size: 13px; box-sizing: border-box; }
        .modal-body input[type="range"] { width: 100%; margin-top: 4px; accent-color: #60a5fa;}
        .modal-body .range-value-display { font-size: 11px; color: #8090a0; display: inline-block; margin-left: 8px; }
        .modal-body input[type="checkbox"] { margin-right: 6px; vertical-align: middle; width: auto; accent-color: #60a5fa; }
        .modal-body .checkbox-label-wrapper { display: flex; align-items: center; } /* For aligning checkbox and label */
        .modal-body .checkbox-label { font-size: 13px; color: #ddeeff; vertical-align: middle; margin-left: 4px; }
        .modal-body .button-group { display: flex; justify-content: flex-end; gap: 8px; margin-top: 18px; }
        .modal-body button, .preset-buttons button { padding: 9px 14px; border: none; border-radius: 5px; cursor: pointer; font-size: 13px; font-weight: 500; transition: background-color 0.2s; }
        .modal-body .btn-primary { background-color: #3b82f6; color: white; } .modal-body .btn-primary:hover { background-color: #2563eb; }
        .modal-body .btn-secondary { background-color: #4a5568; color: #e0e8ff; } .modal-body .btn-secondary:hover { background-color: #3b4558; }
        .modal-body .btn-danger { background-color: #ef4444; color: white; } .modal-body .btn-danger:hover { background-color: #dc2626; }
        .preset-buttons { display: grid; grid-template-columns: repeat(auto-fit, minmax(110px, 1fr)); gap: 8px; }
        .custom-add-separator { margin-top: 18px; border-top: 1px solid rgba(255,255,255,0.08); padding-top: 12px; }
        .disabled-text { color: #708090; font-size: 11px; margin-top: 3px; }
        #time-controls-form-container .time-button-group { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 15px; }
        #time-controls-form-container .time-button-group button { flex-grow: 1; }
        #time-controls-form-container .current-speed-display { text-align: center; font-size: 14px; margin-bottom: 15px; color: #a0b0c0; }
        #time-controls-form-container .current-speed-display strong { color: #e0e8ff; }
        .focus-btn-group { margin-top: 10px; }
    </style>
</head>
<body>
    <div id="info-overlay">
        <b>Space Facric Visualizer</b><br>
        Drag to orbit, Pinch to zoom. Tap objects to select/edit.
    </div>
    <div id="hud">
        <div id="hud-sim-speed">Sim Speed: 1.0x</div>
        <div id="hud-selected-obj">Selected: None</div>
        <div id="hud-obj-stats"></div>
        <!-- <div id="hud-date-time">Date: N/A</div> -->
    </div>

    <div id="bottom-toolbar">
        <button id="btn-add-preset" title="Add Body/Scenario"><svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg><span>Add</span></button>
        <button id="btn-edit-selected" title="Edit Selected Body" disabled><svg viewBox="0 0 24 24"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34a.9959.9959 0 00-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg><span>Edit</span></button>
        <button id="btn-time-controls" title="Time Controls"><svg viewBox="0 0 24 24"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm.5-13H11v6l5.25 3.15.75-1.23-4.5-2.67z"/></svg><span>Time</span></button>
        <button id="btn-grid-settings" title="Grid Settings"><svg viewBox="0 0 24 24"><path d="M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z"/></svg><span>Grid</span></button>
        <button id="btn-reset-sim" title="Reset Simulation"><svg viewBox="0 0 24 24"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg><span>Reset</span></button>
    </div>

    <div id="modals-container">
        <div id="preset-modal" class="modal"><div class="modal-content"><div class="modal-header"><h3>Add Celestial Body/Scenario</h3><button class="modal-close-btn" data-modal-id="preset-modal">&times;</button></div><div class="modal-body"><div class="preset-buttons" id="preset-buttons-container"></div><div class="form-group custom-add-separator"><label>Or Add Custom:</label><button id="btn-add-custom-from-modal" class="btn-secondary">Add Custom Body</button></div></div></div></div>
        <div id="edit-body-modal" class="modal"><div class="modal-content"><div class="modal-header"><h3 id="edit-body-name">Edit Body</h3><button class="modal-close-btn" data-modal-id="edit-body-modal">&times;</button></div><div class="modal-body" id="edit-body-form-container"></div></div></div>
        <div id="grid-settings-modal" class="modal"><div class="modal-content"><div class="modal-header"><h3>Grid Settings</h3><button class="modal-close-btn" data-modal-id="grid-settings-modal">&times;</button></div><div class="modal-body" id="grid-settings-form-container"></div></div></div>
        <div id="custom-body-modal" class="modal"><div class="modal-content"><div class="modal-header"><h3>Add Custom Body</h3><button class="modal-close-btn" data-modal-id="custom-body-modal">&times;</button></div><div class="modal-body" id="custom-body-form-container"></div></div></div>
        <div id="time-controls-modal" class="modal"><div class="modal-content"><div class="modal-header"><h3>Time Controls</h3><button class="modal-close-btn" data-modal-id="time-controls-modal">&times;</button></div><div class="modal-body" id="time-controls-form-container"></div></div></div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script type="module">
        // --- CONFIGURATION ---
        const G_PHYSICS = 0.8; // Arbitrary gravitational constant for simulation scaling
        let GRID_CONFIG = {
            EXTENT: 900, LINES_PER_AXIS_GROUP: 7, POINTS_PER_LINE: 22,
            COLOR: '#336699', OPACITY: 0.20, MASS_THRESHOLD_FOR_WARP: 2,
            MAX_INFLUENCE_RADIUS_FACTOR: 55, VISUAL_WARP_STRENGTH: 28,
            SOFTENING_FACTOR: 0.45, PULL_EXPONENT: 1.22,
        };
        const TEXTURE_PATHS = {
            skybox: [ 'https://threejs.org/examples/textures/cube/MilkyWay/px.jpg', 'https://threejs.org/examples/textures/cube/MilkyWay/nx.jpg', 'https://threejs.org/examples/textures/cube/MilkyWay/py.jpg', 'https://threejs.org/examples/textures/cube/MilkyWay/ny.jpg', 'https://threejs.org/examples/textures/cube/MilkyWay/pz.jpg', 'https://threejs.org/examples/textures/cube/MilkyWay/nz.jpg' ],
            sun: 'https://i.imgur.com/ZfhKxS2.jpeg', earth: 'https://i.imgur.com/D817tLg.jpeg', moon: 'https://i.imgur.com/7Zp2L2I.jpeg', mars: 'https://i.imgur.com/U9k2KQE.jpeg', jupiter: 'https://i.imgur.com/xTKkj74.jpeg', saturn: 'https://i.imgur.com/bOl20B9.jpeg', saturnRing: 'https://i.imgur.com/j6wKzFh.png'
        };
        const PRESET_BODIES = {
            sun: { name: "Sun", mass: 2200, radius: 75, color: 0xFFEE88, textureKey: 'sun', emissive: 0xFFDD55, isGridWarper: true, axialTilt: 0.126, rotationSpeed: 0.0004, isStar: true },
            earth: { name: "Earth", mass: 100, radius: 20, color: 0x6699FF, textureKey: 'earth', isGridWarper: true, axialTilt: 0.409, rotationSpeed: 0.015 },
            moon: { name: "Moon", mass: 1.2, radius: 5.5, color: 0xAAAAAA, textureKey: 'moon', isGridWarper: true, axialTilt: 0.116, rotationSpeed: 0.001 },
            mars: { name: "Mars", mass: 10.7, radius: 10.6, color: 0xFF6633, textureKey: 'mars', isGridWarper: true, axialTilt: 0.439, rotationSpeed: 0.014 },
            jupiter: { name: "Jupiter", mass: 700, radius: 60, color: 0xDDAA77, textureKey: 'jupiter', isGridWarper: true, axialTilt: 0.054, rotationSpeed: 0.035 },
            saturn: { name: "Saturn", mass: 400, radius: 50, color: 0xF0E68C, textureKey: 'saturn', isGridWarper: true, hasRing: true, axialTilt: 0.466, rotationSpeed: 0.032 },
            blackhole: { name: "Black Hole", mass: 4500, radius: 8, color: 0x030303, isGridWarper: true, emissive: 0x010101, pullExponent: 1.7, axialTilt: 0, rotationSpeed: 0, isStar: true }, // isStar:true makes it a potential light source
        };
        const PRESET_SCENARIOS = {
            earthMoonSys: { name: "Earth-Moon System", isScenario: true, action: addEarthMoonSystem },
            solarSysBasic: { name: "Solar System", isScenario: true, action: addSolarSystemBasic }
        };
        const CUSTOM_BODY_DEFAULTS = {
            name: "Custom Planet", mass: 50, radius: 15, posX: 0, posY: 0, posZ: 0,
            velX: 0, velY: 0, velZ: 0, color: '#00FF00', isGridWarper: true,
            axialTilt: 0, rotationSpeed: 0.01
        };
        const TIME_MULTIPLIERS = [0.1, 0.25, 0.5, 1, 2, 5, 10, 25, 50, 100];
        let currentSimSpeedMultiplier = 1;

        // --- THREE.JS & SIMULATION GLOBALS ---
        let scene, camera, renderer, controls, textureLoader, skyboxLoader;
        const celestialBodies = [];
        let gridLines = [];
        let sharedLineMaterial;
        let selectedBody = null;
        let isCameraTracking = false;
        const cameraTarget = new THREE.Vector3(); // For smooth camera movement
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        let isPointerDragging = false;
        let pointerDownTime = 0;
        let lastFrameTime = 0;

        // --- DOM ELEMENTS ---
        const hudSimSpeedEl = document.getElementById('hud-sim-speed');
        const hudSelectedObjEl = document.getElementById('hud-selected-obj');
        const hudObjStatsEl = document.getElementById('hud-obj-stats');
        const btnAddPreset = document.getElementById('btn-add-preset');
        const btnEditSelected = document.getElementById('btn-edit-selected');
        const btnTimeControls = document.getElementById('btn-time-controls');
        const btnGridSettings = document.getElementById('btn-grid-settings');
        const btnResetSim = document.getElementById('btn-reset-sim');
        const allModals = Array.from(document.querySelectorAll('.modal'));


        // --- INITIALIZATION ---
        function init() {
            // Scene
            scene = new THREE.Scene();
            // scene.fog = new THREE.FogExp2(0x000000, 0.0007); // Optional subtle fog

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.2, GRID_CONFIG.EXTENT * 5);
            camera.position.set(GRID_CONFIG.EXTENT * 0.5, GRID_CONFIG.EXTENT * 0.35, GRID_CONFIG.EXTENT * 0.9);
            cameraTarget.copy(scene.position);
            camera.lookAt(cameraTarget);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Cap pixel ratio
            document.body.insertBefore(renderer.domElement, document.getElementById('bottom-toolbar')); // Insert canvas

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.04;
            controls.minDistance = 5;
            controls.maxDistance = GRID_CONFIG.EXTENT * 3.5;
            controls.target.copy(cameraTarget); // Ensure controls start at the same target

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xaaaaaa); // Slightly brighter ambient
            scene.add(ambientLight);
            const sunLight = new THREE.PointLight(0xffffee, 1.5, GRID_CONFIG.EXTENT * 4 , 1.8); // Main light, like a sun
            sunLight.position.set(0,0,0); // Will be updated if a "Sun" body exists
            scene.add(sunLight);
            // Store sunLight globally to update its position if a sun-like body is added/moved
            scene.userData.sunLight = sunLight;


            // Loaders
            textureLoader = new THREE.TextureLoader();
            skyboxLoader = new THREE.CubeTextureLoader();

            // Skybox
            const skyboxTexture = skyboxLoader.load(TEXTURE_PATHS.skybox);
            scene.background = skyboxTexture;

            // Grid Material
            sharedLineMaterial = new THREE.LineBasicMaterial({
                color: new THREE.Color(GRID_CONFIG.COLOR),
                transparent: true,
                opacity: GRID_CONFIG.OPACITY
            });

            // Setup UI and initial state
            setup3DGrid();
            setupUIEventHandlers();
            populatePresetModal();
            populateGridSettingsModal();
            populateTimeControlsModal();
            
            addSolarSystemBasic(); // Start with a default scenario

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            renderer.domElement.addEventListener('pointerdown', onCanvasPointerDown, false);
            
            // Start animation loop
            animate();
        }

        // --- UTILITY FUNCTIONS ---
        function calculateGScaled(mass, radius, G_constant) {
            if (radius <= 0) return 0;
            return (G_constant * mass) / (radius * radius);
        }

        // --- UI MANAGEMENT ---
        function setupUIEventHandlers() {
            document.querySelectorAll('.modal-close-btn').forEach(btn => {
                btn.addEventListener('click', () => closeModal(document.getElementById(btn.dataset.modalId)));
            });
            allModals.forEach(modal => {
                modal.addEventListener('click', (event) => { if (event.target === modal) closeModal(modal); });
            });

            btnAddPreset.addEventListener('click', () => openModalById('preset-modal'));
            btnEditSelected.addEventListener('click', () => {
                if (selectedBody) { populateEditBodyModal(); openModalById('edit-body-modal'); }
            });
            btnTimeControls.addEventListener('click', () => openModalById('time-controls-modal'));
            btnGridSettings.addEventListener('click', () => openModalById('grid-settings-modal'));
            btnResetSim.addEventListener('click', () => {
                if (confirm("Reset simulation and remove all bodies?")) resetSimulationInternal();
            });
            document.getElementById('btn-add-custom-from-modal').addEventListener('click', () => {
                closeModalById('preset-modal'); populateCustomBodyModal(); openModalById('custom-body-modal');
            });
        }

        function openModalById(modalId) {
            const modalElement = document.getElementById(modalId);
            if (modalElement) {
                modalElement.classList.add('active');
                controls.enabled = false;
            }
        }
        function closeModalById(modalId) {
            const modalElement = document.getElementById(modalId);
            if (modalElement) {
                modalElement.classList.remove('active');
                controls.enabled = true;
            }
        }
        function closeModal(modalElement) { // General close for any modal
            if(modalElement) modalElement.classList.remove('active');
            controls.enabled = true;
        }

        function createFormInput(id, labelText, type, value, options = {}) {
            const group = document.createElement('div'); group.className = 'form-group';
            const label = document.createElement('label'); label.htmlFor = id;
            let input, valueDisplaySpan;

            if (type === 'checkbox') {
                label.appendChild(document.createTextNode(options.checkLabel || labelText)); // Text first for checkbox
            } else {
                label.textContent = labelText;
                group.appendChild(label);
            }
            
            if (type === 'range') {
                input = document.createElement('input'); input.type = 'range';
                input.min = options.min || 0; input.max = options.max || 100; input.step = options.step || 0.01;
                valueDisplaySpan = document.createElement('span'); valueDisplaySpan.className = 'range-value-display';
                valueDisplaySpan.textContent = parseFloat(value).toFixed(options.decimals ?? 2);
                input.addEventListener('input', () => valueDisplaySpan.textContent = parseFloat(input.value).toFixed(options.decimals ?? 2));
                group.appendChild(valueDisplaySpan);
            } else if (type === 'checkbox') {
                const wrapper = document.createElement('div'); wrapper.className = 'checkbox-label-wrapper';
                input = document.createElement('input'); input.type = 'checkbox'; input.checked = !!value;
                wrapper.appendChild(input);
                wrapper.appendChild(label); // Label now contains text due to above logic
                group.appendChild(wrapper); // Add wrapper to group
            } else {
                input = document.createElement('input'); input.type = type;
                if(type === 'number'){ if(options.min !== undefined) input.min=options.min; if(options.max !== undefined) input.max=options.max; if(options.step !== undefined) input.step=options.step;}
            }
            if (input) { // Ensure input was created
                 input.id = id; input.name = id; input.value = value;
                if (type !== 'checkbox') group.appendChild(input); // Checkbox is inside wrapper
            }
            if(options.disabledText) { const p = document.createElement('p'); p.className='disabled-text'; p.textContent=options.disabledText; group.appendChild(p); }
            return group;
        }

        function populatePresetModal() {
            const container = document.getElementById('preset-buttons-container'); container.innerHTML = '';
            for (const key in PRESET_BODIES) {
                const preset = PRESET_BODIES[key];
                const button = document.createElement('button'); button.classList.add('btn-secondary'); button.textContent = preset.name;
                button.addEventListener('click', () => { addPresetBody(key); closeModalById('preset-modal'); });
                container.appendChild(button);
            }
            for (const key in PRESET_SCENARIOS) {
                const scenario = PRESET_SCENARIOS[key];
                const button = document.createElement('button'); button.classList.add('btn-primary'); button.textContent = scenario.name;
                button.addEventListener('click', () => { scenario.action(); closeModalById('preset-modal'); });
                container.appendChild(button);
            }
        }
        
        function populateEditBodyModal() {
            if (!selectedBody) return;
            const formContainer = document.getElementById('edit-body-form-container'); formContainer.innerHTML = '';
            document.getElementById('edit-body-name').textContent = `Edit: ${selectedBody.name}`;
            const currentG = calculateGScaled(selectedBody.mass, selectedBody.radius, G_PHYSICS).toFixed(4); // Calculate and format

            formContainer.appendChild(createFormInput('edit-name', 'Name:', 'text', selectedBody.name));
            formContainer.appendChild(createFormInput('edit-mass', 'Mass:', 'number', selectedBody.mass, {min:0.01, step: 0.1}));
            formContainer.appendChild(createFormInput('edit-radius', 'Radius:', 'number', selectedBody.radius, {min:0.1, step: 0.1}));
            formContainer.appendChild(createFormInput('edit-g', `Surface g (now: ${currentG}):`, 'number', currentG, {min:0.001, step:0.01, disabledText: "Changes Mass if altered."}));
            formContainer.appendChild(createFormInput('edit-posX', 'Pos X:', 'number', selectedBody.tiltObject.position.x.toFixed(1), {step:1}));
            formContainer.appendChild(createFormInput('edit-posY', 'Pos Y:', 'number', selectedBody.tiltObject.position.y.toFixed(1), {step:1}));
            formContainer.appendChild(createFormInput('edit-posZ', 'Pos Z:', 'number', selectedBody.tiltObject.position.z.toFixed(1), {step:1}));
            formContainer.appendChild(createFormInput('edit-velX', 'Vel X:', 'number', selectedBody.velocity.x.toFixed(2), {step: 0.05, min: -30, max: 30}));
            formContainer.appendChild(createFormInput('edit-velY', 'Vel Y:', 'number', selectedBody.velocity.y.toFixed(2), {step: 0.05, min: -30, max: 30}));
            formContainer.appendChild(createFormInput('edit-velZ', 'Vel Z:', 'number', selectedBody.velocity.z.toFixed(2), {step: 0.05, min: -30, max: 30}));
            formContainer.appendChild(createFormInput('edit-axialTilt', 'Axial Tilt (rad):', 'number', selectedBody.axialTilt.toFixed(3), {step: 0.001, min: -Math.PI/2, max: Math.PI/2}));
            formContainer.appendChild(createFormInput('edit-rotationSpeed', 'Rotation Spd (rad/t):', 'number', selectedBody.rotationSpeed.toFixed(4), {step: 0.0001, min: -0.1, max: 0.1}));
            formContainer.appendChild(createFormInput('edit-isGridWarper', '', 'checkbox', selectedBody.isGridWarper, {checkLabel: 'Warps Grid'}));

            const focusGroup = document.createElement('div'); focusGroup.className = 'form-group focus-btn-group';
            const trackBtn = document.createElement('button'); trackBtn.textContent = isCameraTracking && controls.target.equals(selectedBody.tiltObject.position) ? 'Stop Tracking' : 'Focus & Track';
            trackBtn.className = 'btn-secondary';
            trackBtn.onclick = () => {
                if (isCameraTracking && controls.target.equals(selectedBody.tiltObject.position)) {
                    isCameraTracking = false;
                    trackBtn.textContent = 'Focus & Track';
                } else {
                    isCameraTracking = true;
                    // cameraTarget is updated in updateCamera if isCameraTracking and selectedBody exist
                    trackBtn.textContent = 'Stop Tracking';
                }
                 // closeModalById('edit-body-modal'); // Optional: close modal on track
            };
            focusGroup.appendChild(trackBtn);
            formContainer.appendChild(focusGroup);


            const btnGroup = document.createElement('div'); btnGroup.className = 'button-group';
            const saveBtn = document.createElement('button'); saveBtn.textContent = 'Save'; saveBtn.className = 'btn-primary';
            saveBtn.addEventListener('click', () => {
                selectedBody.name = document.getElementById('edit-name').value;
                const newGInput = parseFloat(document.getElementById('edit-g').value);
                const newRadius = parseFloat(document.getElementById('edit-radius').value);

                // Check if 'g' was significantly changed by the user
                if (Math.abs(newGInput - parseFloat(currentG)) > 1e-5 && newRadius > 0) {
                    selectedBody.mass = (newGInput * newRadius * newRadius) / G_PHYSICS;
                } else { 
                    selectedBody.mass = parseFloat(document.getElementById('edit-mass').value); 
                }
                selectedBody.radius = newRadius;
                
                selectedBody.tiltObject.position.set(parseFloat(document.getElementById('edit-posX').value), parseFloat(document.getElementById('edit-posY').value), parseFloat(document.getElementById('edit-posZ').value));
                selectedBody.velocity.set(parseFloat(document.getElementById('edit-velX').value), parseFloat(document.getElementById('edit-velY').value), parseFloat(document.getElementById('edit-velZ').value));
                selectedBody.axialTilt = parseFloat(document.getElementById('edit-axialTilt').value);
                selectedBody.rotationSpeed = parseFloat(document.getElementById('edit-rotationSpeed').value);
                selectedBody.isGridWarper = document.getElementById('edit-isGridWarper').checked;
                updateBodyVisuals(selectedBody); deform3DGrid(); closeModalById('edit-body-modal');
            });
            const deleteBtn = document.createElement('button'); deleteBtn.textContent = 'Delete'; deleteBtn.className = 'btn-danger';
            deleteBtn.addEventListener('click', () => {
                if(confirm(`Delete ${selectedBody.name}?`)){
                    const index = celestialBodies.indexOf(selectedBody);
                    if (index > -1) {
                        scene.remove(selectedBody.tiltObject); // Remove tiltObject from scene
                        if (selectedBody.orbitLine) { scene.remove(selectedBody.orbitLine); selectedBody.orbitLine.geometry.dispose(); }
                        celestialBodies.splice(index, 1);
                        disposeBodyAssets(selectedBody);
                        
                        if (isCameraTracking && controls.target.equals(selectedBody.tiltObject.position)) {
                           isCameraTracking = false; // Stop tracking if deleted body was tracked
                        }
                        selectedBody = null; 
                        updateEditButtonState(); 
                        deform3DGrid(); 
                        closeModalById('edit-body-modal');
                    }
                }
            });
            btnGroup.appendChild(deleteBtn); btnGroup.appendChild(saveBtn); formContainer.appendChild(btnGroup);
        }

        function populateGridSettingsModal() {
            const c = document.getElementById('grid-settings-form-container'); c.innerHTML = '';
            c.appendChild(createFormInput('grid-extent', 'Size:', 'range', GRID_CONFIG.EXTENT, {min:200, max:3000, step:50, decimals:0}));
            c.appendChild(createFormInput('grid-lines', 'Density:', 'range', GRID_CONFIG.LINES_PER_AXIS_GROUP, {min:2, max:15, step:1, decimals:0}));
            c.appendChild(createFormInput('grid-points', 'Smoothness:', 'range', GRID_CONFIG.POINTS_PER_LINE, {min:5, max:50, step:1, decimals:0}));
            c.appendChild(createFormInput('grid-warp', 'Warp Strength:', 'range', GRID_CONFIG.VISUAL_WARP_STRENGTH, {min:1, max:150, step:1, decimals:0}));
            c.appendChild(createFormInput('grid-pull', 'Pull Exponent:', 'range', GRID_CONFIG.PULL_EXPONENT, {min:1.0, max:2.5, step:0.01}));
            c.appendChild(createFormInput('grid-color', 'Color:', 'color', GRID_CONFIG.COLOR));
            c.appendChild(createFormInput('grid-opacity', 'Opacity:', 'range', GRID_CONFIG.OPACITY, {min:0.0, max:1, step:0.01}));
            const btnGroup = document.createElement('div'); btnGroup.className = 'button-group';
            const applyBtn = document.createElement('button'); applyBtn.textContent = 'Apply'; applyBtn.className = 'btn-primary';
            applyBtn.onclick = () => {
                const oldD = GRID_CONFIG.LINES_PER_AXIS_GROUP, oldS = GRID_CONFIG.POINTS_PER_LINE, oldE = GRID_CONFIG.EXTENT;
                GRID_CONFIG.EXTENT = parseFloat(document.getElementById('grid-extent').value);
                GRID_CONFIG.LINES_PER_AXIS_GROUP = parseInt(document.getElementById('grid-lines').value);
                GRID_CONFIG.POINTS_PER_LINE = parseInt(document.getElementById('grid-points').value);
                GRID_CONFIG.VISUAL_WARP_STRENGTH = parseFloat(document.getElementById('grid-warp').value);
                GRID_CONFIG.PULL_EXPONENT = parseFloat(document.getElementById('grid-pull').value);
                GRID_CONFIG.COLOR = document.getElementById('grid-color').value;
                GRID_CONFIG.OPACITY = parseFloat(document.getElementById('grid-opacity').value);
                if (GRID_CONFIG.LINES_PER_AXIS_GROUP !== oldD || GRID_CONFIG.POINTS_PER_LINE !== oldS || GRID_CONFIG.EXTENT !== oldE) remakeGrid();
                else { updateGridMaterial(); deform3DGrid(); }
                closeModalById('grid-settings-modal');
            };
            btnGroup.appendChild(applyBtn); c.appendChild(btnGroup);
        }
        
        function populateCustomBodyModal() {
            const c = document.getElementById('custom-body-form-container'); c.innerHTML = ''; const p = CUSTOM_BODY_DEFAULTS;
            c.appendChild(createFormInput('custom-name', 'Name:', 'text', p.name));
            c.appendChild(createFormInput('custom-mass', 'Mass:', 'number', p.mass, {min:0.1, step:1}));
            c.appendChild(createFormInput('custom-radius', 'Radius:', 'number', p.radius, {min:0.1, step:0.5}));
            c.appendChild(createFormInput('custom-posX', 'Pos X:', 'number', p.posX, {step:10}));
            c.appendChild(createFormInput('custom-posY', 'Pos Y:', 'number', p.posY, {step:10}));
            c.appendChild(createFormInput('custom-posZ', 'Pos Z:', 'number', p.posZ, {step:10}));
            c.appendChild(createFormInput('custom-velX', 'Vel X:', 'number', p.velX, {step:0.1, min:-30,max:30}));
            c.appendChild(createFormInput('custom-velY', 'Vel Y:', 'number', p.velY, {step:0.1, min:-30,max:30}));
            c.appendChild(createFormInput('custom-velZ', 'Vel Z:', 'number', p.velZ, {step:0.1, min:-30,max:30}));
            c.appendChild(createFormInput('custom-axialTilt', 'Axial Tilt (rad):', 'number', p.axialTilt, {step: 0.01, min: -Math.PI/2, max: Math.PI/2}));
            c.appendChild(createFormInput('custom-rotationSpeed', 'Rotation Spd (rad/t):', 'number', p.rotationSpeed, {step: 0.001, min:-0.1,max:0.1}));
            c.appendChild(createFormInput('custom-color', 'Color:', 'color', p.color));
            c.appendChild(createFormInput('custom-isGridWarper', '', 'checkbox', p.isGridWarper, {checkLabel:"Warps Grid"}));
            const btnGroup = document.createElement('div'); btnGroup.className = 'button-group';
            const addBtn = document.createElement('button'); addBtn.textContent = 'Add Body'; addBtn.className = 'btn-primary';
            addBtn.onclick = () => {
                addCelestialBody({
                    name: document.getElementById('custom-name').value, mass: parseFloat(document.getElementById('custom-mass').value), radius: parseFloat(document.getElementById('custom-radius').value),
                    position: new THREE.Vector3(parseFloat(document.getElementById('custom-posX').value), parseFloat(document.getElementById('custom-posY').value), parseFloat(document.getElementById('custom-posZ').value)),
                    velocity: new THREE.Vector3(parseFloat(document.getElementById('custom-velX').value), parseFloat(document.getElementById('custom-velY').value), parseFloat(document.getElementById('custom-velZ').value)),
                    axialTilt: parseFloat(document.getElementById('custom-axialTilt').value), rotationSpeed: parseFloat(document.getElementById('custom-rotationSpeed').value),
                    color: document.getElementById('custom-color').value, isGridWarper: document.getElementById('custom-isGridWarper').checked });
                closeModalById('custom-body-modal');
            };
            btnGroup.appendChild(addBtn); c.appendChild(btnGroup);
        }

        function populateTimeControlsModal() {
            const container = document.getElementById('time-controls-form-container'); container.innerHTML = '';
            const currentSpeedDiv = document.createElement('div'); currentSpeedDiv.className = 'current-speed-display';
            currentSpeedDiv.innerHTML = `Current Speed: <strong>${currentSimSpeedMultiplier.toFixed(2)}x</strong>`;
            container.appendChild(currentSpeedDiv);

            const group = document.createElement('div'); group.className = 'time-button-group';
            TIME_MULTIPLIERS.forEach(multiplier => {
                const btn = document.createElement('button');
                btn.textContent = `${multiplier}x`;
                btn.className = 'btn-secondary';
                btn.onclick = () => {
                    currentSimSpeedMultiplier = multiplier;
                    hudSimSpeedEl.textContent = `Sim Speed: ${currentSimSpeedMultiplier.toFixed(2)}x`;
                    currentSpeedDiv.innerHTML = `Current Speed: <strong>${currentSimSpeedMultiplier.toFixed(2)}x</strong>`;
                    // closeModalById('time-controls-modal'); // Optional: close on selection
                };
                group.appendChild(btn);
            });
            container.appendChild(group);
        }

        function updateHUD() {
            hudSimSpeedEl.textContent = `Sim Speed: ${currentSimSpeedMultiplier.toFixed(2)}x`;
            if (selectedBody) {
                hudSelectedObjEl.textContent = `Selected: ${selectedBody.name}`;
                let statsHTML = `Mass: ${selectedBody.mass.toFixed(1)}<br>Radius: ${selectedBody.radius.toFixed(1)}<br>Vel: ${selectedBody.velocity.length().toFixed(2)}`;
                // Attempt to find a primary if orbiting
                let primary = findPrimary(selectedBody);
                if (primary) {
                    const dist = selectedBody.tiltObject.position.distanceTo(primary.tiltObject.position);
                    statsHTML += `<br>Dist to ${primary.name}: ${dist.toFixed(0)}`;
                }
                hudObjStatsEl.innerHTML = statsHTML;
            } else {
                hudSelectedObjEl.textContent = "Selected: None";
                hudObjStatsEl.innerHTML = "";
            }
        }
        function updateEditButtonState() { btnEditSelected.disabled = !selectedBody; }

        // --- SIMULATION LOGIC (Celestial Bodies, Grid, Physics) ---
        function addCelestialBody(params) {
            const { mass, radius, position, velocity = new THREE.Vector3(), color = 0xffffff, textureKey, emissive, hasRing, isGridWarper = false, name = "Body", axialTilt = 0, rotationSpeed = 0, isStar = false, pullExponent } = params;
            
            const materialParams = { shininess: isStar ? 0 : 25, color: new THREE.Color(color) };
            if (emissive) { materialParams.emissive = new THREE.Color(emissive); if(!textureKey || !isStar) materialParams.color.set(0x000000); } // if emissive and no texture, base color black
            if (textureKey && TEXTURE_PATHS[textureKey]) {
                try {
                    const map = textureLoader.load(TEXTURE_PATHS[textureKey]);
                    materialParams.map = map;
                    if (isStar && emissive) materialParams.emissiveMap = map; // Sun uses texture for emission
                } catch (e) { console.error("Texture load fail:", textureKey, e); }
            }
            
            const geometry = new THREE.SphereGeometry(1, 24, 16); // Segments for sphere
            const material = new THREE.MeshPhongMaterial(materialParams);
            const mesh = new THREE.Mesh(geometry, material);
            
            const tiltObject = new THREE.Object3D();
            tiltObject.rotation.z = axialTilt; // Tilt around Z for Y-up world (effectively tilts planet's north pole along Y axis in its own XY plane)
            tiltObject.add(mesh); 

            tiltObject.scale.setScalar(radius); 
            tiltObject.position.copy(position);

            const body = {
                tiltObject: tiltObject, 
                mesh: mesh, 
                mass, radius, initialRadiusForRing: radius, velocity: velocity.clone(), acceleration: new THREE.Vector3(),
                isGridWarper, name, axialTilt, rotationSpeed, isStar, pullExponent,
                orbitPath: [], orbitLine: null, maxOrbitPoints: 150 + Math.min(mass, 200), 
                ringMesh: null
            };
            mesh.userData.body = body; // Link back for raycasting

            if (hasRing && name === "Saturn") { // Specific logic for Saturn's rings
                const ringOuter = 1 * 2.2; const ringInner = 1 * 1.4; 
                const ringGeom = new THREE.RingGeometry(ringInner, ringOuter, 48, 2);
                const ringMatParams = { side: THREE.DoubleSide, transparent: true, opacity: 0.75 };
                if (TEXTURE_PATHS.saturnRing) {
                    try { 
                        const ringTexture = textureLoader.load(TEXTURE_PATHS.saturnRing);
                        ringMatParams.map = ringTexture; 
                        ringMatParams.alphaMap = ringTexture; // Use texture for alpha as well for transparency
                    } catch(e){ console.error("Saturn ring texture load fail:", e); }
                } else { ringMatParams.color = new THREE.Color(color).offsetHSL(0,0,0.15); }
                const ringMaterial = new THREE.MeshBasicMaterial(ringMatParams);
                const ringMesh = new THREE.Mesh(ringGeom, ringMaterial);
                ringMesh.rotation.x = Math.PI / 2; // Orient ring to lie in planet's XY plane (equatorial)
                mesh.add(ringMesh); 
                body.ringMesh = ringMesh;
            }
            celestialBodies.push(body);
            scene.add(tiltObject); 

            if (isStar && scene.userData.sunLight) {
                scene.userData.sunLight.position.copy(tiltObject.position);
            }
            return body;
        }
        
        function updateBodyVisuals(body) { 
            body.tiltObject.scale.setScalar(body.radius);
            body.tiltObject.rotation.z = body.axialTilt; // Update tilt on the parent
            // Ring mesh is a child of body.mesh, which is a child of tiltObject.
            // Its geometry is unit-based. The scale of tiltObject handles planet size.
            // Ring orientation (rotation.x) is relative to planet's mesh, so it tilts with planet.
            if (body.isStar && scene.userData.sunLight) {
                scene.userData.sunLight.position.copy(body.tiltObject.position);
            }
        }
        
        function disposeBodyAssets(body) {
            body.mesh.geometry.dispose();
            if(body.mesh.material.map) body.mesh.material.map.dispose();
            if(body.mesh.material.emissiveMap) body.mesh.material.emissiveMap.dispose();
            body.mesh.material.dispose();
            if(body.ringMesh){
                body.ringMesh.geometry.dispose();
                if(body.ringMesh.material.map) body.ringMesh.material.map.dispose();
                if(body.ringMesh.material.alphaMap) body.ringMesh.material.alphaMap.dispose(); // if alphaMap is same as map, it's disposed once
                body.ringMesh.material.dispose();
            }
        }

        function addPresetBody(key, customParams = {}) {
            const preset = PRESET_BODIES[key]; if (!preset) return;
            const params = { ...preset, ...customParams };
            params.position = params.position || new THREE.Vector3((Math.random()-0.5)*GRID_CONFIG.EXTENT*0.4, (Math.random()-0.5)*GRID_CONFIG.EXTENT*0.1, (Math.random()-0.5)*GRID_CONFIG.EXTENT*0.4);
            params.velocity = params.velocity || new THREE.Vector3();
            return addCelestialBody(params);
        }
        function addEarthMoonSystem() {
            resetSimulationInternal();
            const earth = addPresetBody('earth', { position: new THREE.Vector3(0,0,0), velocity: new THREE.Vector3(0,0,0) });
            const moonOrbitDist = PRESET_BODIES.earth.radius + PRESET_BODIES.moon.radius + 35;
            const moonOrbitalSpeed = Math.sqrt((G_PHYSICS * earth.mass) / moonOrbitDist);
            addPresetBody('moon', { position: new THREE.Vector3(moonOrbitDist, 0, 0), velocity: new THREE.Vector3(0, 0, -moonOrbitalSpeed) });
            setCameraTarget(earth.tiltObject.position, true); 
        }
        function addSolarSystemBasic() {
            resetSimulationInternal();
            const sun = addPresetBody('sun', { position: new THREE.Vector3(0,0,0), velocity: new THREE.Vector3(0,0,0) });
            const planetData = [
                { key: 'earth', dist: 180, speedFactor: 1.0 }, { key: 'mars', dist: 250, speedFactor: 0.82 },
                { key: 'jupiter', dist: 450, speedFactor: 0.45 }, { key: 'saturn', dist: 650, speedFactor: 0.33 },
            ];
            planetData.forEach(pD => {
                const angle = Math.random()*Math.PI*2;
                const posX = pD.dist*Math.cos(angle); const posZ = pD.dist*Math.sin(angle);
                const orbitalSpeed = Math.sqrt((G_PHYSICS * sun.mass) / pD.dist) * pD.speedFactor;
                const velX = -orbitalSpeed*Math.sin(angle); const velZ = orbitalSpeed*Math.cos(angle);
                addPresetBody(pD.key, {position: new THREE.Vector3(posX, (Math.random()-0.5)*10, posZ), velocity: new THREE.Vector3(velX, (Math.random()-0.5)*0.1, velZ)});
            });
            setCameraTarget(sun.tiltObject.position, true); 
        }

        function setup3DGrid() {
            const halfExtent = GRID_CONFIG.EXTENT / 2;
            const linesPerGroup = GRID_CONFIG.LINES_PER_AXIS_GROUP;
            const pointsPerLine = GRID_CONFIG.POINTS_PER_LINE;
            gridLines.forEach(line => { scene.remove(line); line.geometry.dispose(); });
            gridLines = [];
            const createAxisLines = (axisFixed, coord1, coord2) => { // e.g., axisFixed='y', lines are on XZ plane
                for (let i = 0; i <= linesPerGroup; i++) { // Iterate for lines parallel to one axis (e.g., Z-axis if creating XZ plane lines)
                    const pos1 = -halfExtent + (i / linesPerGroup) * GRID_CONFIG.EXTENT; // Position along coord1 (e.g., X)
                    for (let k = 0; k <= linesPerGroup; k++) { // Iterate for lines parallel to other axis (e.g., X-axis)
                        const pos2 = -halfExtent + (k / linesPerGroup) * GRID_CONFIG.EXTENT; // Position along coord2 (e.g., Z)
                        
                        // Create lines PARALLEL to axisFixed, varying along it
                        const points = []; const originalVertices = [];
                        for (let j = 0; j <= pointsPerLine; j++) { // Points along the line
                            const movingCoord = -halfExtent + (j / pointsPerLine) * GRID_CONFIG.EXTENT;
                            const p = new THREE.Vector3(); 
                            p[axisFixed] = movingCoord; // Line extends along axisFixed
                            p[coord1] = pos1;          // Fixed on coord1
                            p[coord2] = pos2;          // Fixed on coord2
                            points.push(p); originalVertices.push(p.clone());
                        }
                        // Check if points are valid before creating line
                        if (points.length > 1) {
                             const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), sharedLineMaterial);
                             line.userData.originalVertices = originalVertices; gridLines.push(line); scene.add(line);
                        }
                    } 
                } 
            };
            // This interpretation of createAxisLines was problematic. A typical grid has lines ALONG axes.
            // Let's define lines on XY, XZ, YZ planes.
            // Lines on XY plane: some parallel to X, some parallel to Y.
            // For XY plane (fixed Z=0, but we do this for multiple Z slices)
            for (let Zslice = -halfExtent; Zslice <= halfExtent; Zslice += GRID_CONFIG.EXTENT / linesPerGroup) {
                // Lines parallel to X
                for (let Ypos = -halfExtent; Ypos <= halfExtent; Ypos += GRID_CONFIG.EXTENT / linesPerGroup) {
                    const points = []; const originalVertices = [];
                    for (let j=0; j<=pointsPerLine; ++j) { const Xpos = -halfExtent + j/pointsPerLine * GRID_CONFIG.EXTENT; points.push(new THREE.Vector3(Xpos, Ypos, Zslice)); originalVertices.push(new THREE.Vector3(Xpos, Ypos, Zslice)); }
                    if (points.length > 1) { const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), sharedLineMaterial); line.userData.originalVertices = originalVertices; gridLines.push(line); scene.add(line); }
                }
                // Lines parallel to Y
                for (let Xpos = -halfExtent; Xpos <= halfExtent; Xpos += GRID_CONFIG.EXTENT / linesPerGroup) {
                    const points = []; const originalVertices = [];
                    for (let j=0; j<=pointsPerLine; ++j) { const Ypos = -halfExtent + j/pointsPerLine * GRID_CONFIG.EXTENT; points.push(new THREE.Vector3(Xpos, Ypos, Zslice)); originalVertices.push(new THREE.Vector3(Xpos, Ypos, Zslice)); }
                     if (points.length > 1) { const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), sharedLineMaterial); line.userData.originalVertices = originalVertices; gridLines.push(line); scene.add(line); }
                }
            }
            // For XZ plane (fixed Y=0, but we do this for multiple Y slices)
             for (let Yslice = -halfExtent; Yslice <= halfExtent; Yslice += GRID_CONFIG.EXTENT / linesPerGroup) {
                // Lines parallel to X
                for (let Zpos = -halfExtent; Zpos <= halfExtent; Zpos += GRID_CONFIG.EXTENT / linesPerGroup) {
                    const points = []; const originalVertices = [];
                    for (let j=0; j<=pointsPerLine; ++j) { const Xpos = -halfExtent + j/pointsPerLine * GRID_CONFIG.EXTENT; points.push(new THREE.Vector3(Xpos, Yslice, Zpos)); originalVertices.push(new THREE.Vector3(Xpos, Yslice, Zpos)); }
                    if (points.length > 1) { const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), sharedLineMaterial); line.userData.originalVertices = originalVertices; gridLines.push(line); scene.add(line); }
                }
                // Lines parallel to Z
                for (let Xpos = -halfExtent; Xpos <= halfExtent; Xpos += GRID_CONFIG.EXTENT / linesPerGroup) {
                    const points = []; const originalVertices = [];
                    for (let j=0; j<=pointsPerLine; ++j) { const Zpos = -halfExtent + j/pointsPerLine * GRID_CONFIG.EXTENT; points.push(new THREE.Vector3(Xpos, Yslice, Zpos)); originalVertices.push(new THREE.Vector3(Xpos, Yslice, Zpos)); }
                     if (points.length > 1) { const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), sharedLineMaterial); line.userData.originalVertices = originalVertices; gridLines.push(line); scene.add(line); }
                }
            }
            // For YZ plane (fixed X=0, but we do this for multiple X slices)
            for (let Xslice = -halfExtent; Xslice <= halfExtent; Xslice += GRID_CONFIG.EXTENT / linesPerGroup) {
                // Lines parallel to Y
                for (let Zpos = -halfExtent; Zpos <= halfExtent; Zpos += GRID_CONFIG.EXTENT / linesPerGroup) {
                    const points = []; const originalVertices = [];
                    for (let j=0; j<=pointsPerLine; ++j) { const Ypos = -halfExtent + j/pointsPerLine * GRID_CONFIG.EXTENT; points.push(new THREE.Vector3(Xslice, Ypos, Zpos)); originalVertices.push(new THREE.Vector3(Xslice, Ypos, Zpos)); }
                    if (points.length > 1) { const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), sharedLineMaterial); line.userData.originalVertices = originalVertices; gridLines.push(line); scene.add(line); }
                }
                // Lines parallel to Z
                for (let Ypos = -halfExtent; Ypos <= halfExtent; Ypos += GRID_CONFIG.EXTENT / linesPerGroup) {
                    const points = []; const originalVertices = [];
                    for (let j=0; j<=pointsPerLine; ++j) { const Zpos = -halfExtent + j/pointsPerLine * GRID_CONFIG.EXTENT; points.push(new THREE.Vector3(Xslice, Ypos, Zpos)); originalVertices.push(new THREE.Vector3(Xslice, Ypos, Zpos)); }
                     if (points.length > 1) { const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), sharedLineMaterial); line.userData.originalVertices = originalVertices; gridLines.push(line); scene.add(line); }
                }
            }
            deform3DGrid();
        }

        function remakeGrid() { setup3DGrid(); }
        function updateGridMaterial() { sharedLineMaterial.color.set(GRID_CONFIG.COLOR); sharedLineMaterial.opacity = GRID_CONFIG.OPACITY; }
        function deform3DGrid() {
            gridLines.forEach(lineMesh => {
                const currentPos = lineMesh.geometry.attributes.position; const origVerts = lineMesh.userData.originalVertices;
                if (!currentPos || !origVerts) return; // Safety check
                for (let i = 0; i < origVerts.length; i++) {
                    const P_orig = origVerts[i]; let cumDisp = new THREE.Vector3(0,0,0);
                    celestialBodies.forEach(body => {
                        if (body.isGridWarper && body.mass >= GRID_CONFIG.MASS_THRESHOLD_FOR_WARP) {
                            const bodyPos = body.tiltObject.position; 
                            const vecToBody = new THREE.Vector3().subVectors(bodyPos, P_orig);
                            let dist = vecToBody.length(); const maxInf = body.radius * GRID_CONFIG.MAX_INFLUENCE_RADIUS_FACTOR;
                            if (dist > 0.01 && dist < maxInf) { // Check dist > 0.01 to avoid issues at center of body
                                const pullExp = body.pullExponent || GRID_CONFIG.PULL_EXPONENT;
                                const effDist = dist + body.radius * GRID_CONFIG.SOFTENING_FACTOR; // Softening for smoother warp near body
                                let dMag = (GRID_CONFIG.VISUAL_WARP_STRENGTH * body.mass) / (Math.pow(effDist, pullExp) + 1e-6); // Add epsilon to avoid div by zero
                                dMag = Math.min(dMag, dist * 0.99); // Cap displacement to prevent overshooting
                                cumDisp.add(vecToBody.normalize().multiplyScalar(dMag));
                            } 
                        } 
                    });
                    const P_new = P_orig.clone().add(cumDisp); currentPos.setXYZ(i, P_new.x, P_new.y, P_new.z);
                } 
                currentPos.needsUpdate = true; 
            });
        }

        function updatePhysics(deltaTime) {
            const dt = Math.min(deltaTime * currentSimSpeedMultiplier, 0.1); // Cap effective dt
            if (dt <= 0) return;

            celestialBodies.forEach(body => body.acceleration.set(0,0,0));
            for (let i=0; i<celestialBodies.length; ++i) {
                for (let j=i+1; j<celestialBodies.length; ++j) {
                    const bodyA = celestialBodies[i], bodyB = celestialBodies[j];
                    const direction = new THREE.Vector3().subVectors(bodyB.tiltObject.position, bodyA.tiltObject.position);
                    let distSq = direction.lengthSq();
                    const colDist = bodyA.radius + bodyB.radius;

                    // Basic collision avoidance / singularity prevention for physics
                    if(distSq < Math.pow(colDist * 0.75, 2)) { // If bodies are very close
                        distSq = Math.max(distSq, Math.pow(colDist * 0.3,2)); // Prevent extreme forces but don't fully stop them
                    }
                    if(distSq < 1e-4) continue; // Avoid division by zero if somehow still too close

                    const forceMag = G_PHYSICS * bodyA.mass * bodyB.mass / distSq;
                    const forceVec = direction.normalize().multiplyScalar(forceMag);
                    if(bodyA.mass > 0) bodyA.acceleration.add(forceVec.clone().divideScalar(bodyA.mass));
                    if(bodyB.mass > 0) bodyB.acceleration.sub(forceVec.clone().divideScalar(bodyB.mass));
                }
            }
            celestialBodies.forEach(body => {
                body.velocity.add(body.acceleration.clone().multiplyScalar(dt));
                body.tiltObject.position.add(body.velocity.clone().multiplyScalar(dt));
                
                // Apply rotation around mesh's local Y axis (day/night cycle)
                if (body.rotationSpeed !== 0) body.mesh.rotation.y += body.rotationSpeed * dt * 25; // Multiplier to make rotation visible

                if (body.isStar && scene.userData.sunLight) scene.userData.sunLight.position.copy(body.tiltObject.position); 

                const trailCondition = body.velocity.lengthSq() > 0.05; 
                if (trailCondition) {
                    body.orbitPath.push(body.tiltObject.position.clone());
                    if(body.orbitPath.length > body.maxOrbitPoints) body.orbitPath.shift();
                    if(body.orbitPath.length > 1) {
                        if(body.orbitLine){ scene.remove(body.orbitLine); body.orbitLine.geometry.dispose(); }
                        const oG = new THREE.BufferGeometry().setFromPoints(body.orbitPath);
                        const trailColorSource = body.mesh.material.emissive && body.mesh.material.emissive.getHex() !== 0 ? body.mesh.material.emissive : body.mesh.material.color;
                        const trailColor = trailColorSource.clone().offsetHSL(0, 0.2, 0.2); // Slightly brighter/more saturated
                        const oM = new THREE.LineBasicMaterial({color: trailColor, transparent: true, opacity: 0.6 }); // Linewidth has limitations
                        body.orbitLine = new THREE.Line(oG,oM); scene.add(body.orbitLine);
                    }
                } else if (body.orbitLine) { scene.remove(body.orbitLine); body.orbitLine.geometry.dispose(); body.orbitLine = null; body.orbitPath = []; }
            });
        }
        
        function resetSimulationInternal() {
            while(celestialBodies.length > 0) {
                const body = celestialBodies.pop();
                scene.remove(body.tiltObject); 
                if (body.orbitLine) { scene.remove(body.orbitLine); body.orbitLine.geometry.dispose(); }
                disposeBodyAssets(body); 
            }
            remakeGrid(); 
            selectedBody = null; updateEditButtonState(); 
            isCameraTracking = false;
            setCameraTarget(new THREE.Vector3(0,0,0), true); // Reset camera target and snap
        }
        
        // --- CAMERA & INTERACTION ---
        function setCameraTarget(newTargetPosition, snap = false) {
            cameraTarget.copy(newTargetPosition); // Target for lerping
            if (snap) {
                controls.target.copy(newTargetPosition);
            }
        }

        function updateCamera(deltaTime) {
            if (isCameraTracking && selectedBody) {
                setCameraTarget(selectedBody.tiltObject.position); // Update lerp target continuously
            }
            // Smoothly interpolate OrbitControls target
            if (!controls.target.equals(cameraTarget)) {
                controls.target.lerp(cameraTarget, Math.min(5 * deltaTime, 1)); 
            }
            controls.update(); 
        }

        function onCanvasPointerDown(event) {
            isPointerDragging = false; pointerDownTime = Date.now();
            // Check if pointer down is on a UI element (modal, toolbar) to prevent raycasting
            if (event.target.closest('.modal, #bottom-toolbar, #info-overlay, #hud')) {
                 return;
            }
            renderer.domElement.addEventListener('pointermove', onPointerMoveDuringDown);
            renderer.domElement.addEventListener('pointerup', onCanvasPointerUp, { once: true });
        }
        function onPointerMoveDuringDown() { isPointerDragging = true; }
        function onCanvasPointerUp(event) {
            renderer.domElement.removeEventListener('pointermove', onPointerMoveDuringDown);
            const pressDuration = Date.now() - pointerDownTime;

            if (!isPointerDragging && pressDuration < 350) { // Tap detection
                const rect = renderer.domElement.getBoundingClientRect();
                pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                raycaster.setFromCamera(pointer, camera);
                const intersects = raycaster.intersectObjects(celestialBodies.map(b => b.mesh), false); // Recursive false, as mesh is direct child of tiltObject which isn't raycast target

                if (intersects.length > 0) {
                    // Intersects returns array of intersection objects. Each object property is the Mesh.
                    // We need to get back to the body object from mesh.userData.body
                    const newSelected = intersects[0].object.userData.body; 
                    
                    if (selectedBody === newSelected) { 
                        if (!document.getElementById('edit-body-modal').classList.contains('active')) {
                             populateEditBodyModal(); openModalById('edit-body-modal');
                        }
                    } else {
                        selectedBody = newSelected;
                        if (!isCameraTracking) { 
                           setCameraTarget(selectedBody.tiltObject.position); // Set new target, will lerp
                        }
                        // If already tracking, updateCamera will pick up new selectedBody
                    }
                } else {
                     // Clicked on empty space, not on UI
                    if (!event.target.closest || !event.target.closest('.modal, #bottom-toolbar, #info-overlay, #hud')) {
                        selectedBody = null; 
                        // Optionally stop tracking if clicking empty space
                        // isCameraTracking = false; 
                    }
                }
                updateEditButtonState();
            }
            isPointerDragging = false;
        }
        
        function findPrimary(body) { 
            let primary = null; let maxMassEffect = 0;
            celestialBodies.forEach(other => {
                if (other === body) return;
                const distSq = body.tiltObject.position.distanceToSquared(other.tiltObject.position);
                if (distSq === 0) return; // Should not happen if distinct objects
                
                // Consider mass and inverse square of distance for "influence"
                // This is a heuristic for "what is it orbiting?"
                const influence = other.mass / distSq; 
                
                if (influence > maxMassEffect && other.mass > body.mass) { // Must be more massive
                    maxMassEffect = influence;
                    primary = other;
                }
            });
            return primary;
        }

        // --- WINDOW & ANIMATION LOOP ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        function animate() {
            requestAnimationFrame(animate);
            const now = performance.now();
            const deltaTime = lastFrameTime > 0 ? (now - lastFrameTime) / 1000 : 0.0166; // seconds
            lastFrameTime = now;

            updatePhysics(deltaTime);
            deform3DGrid();
            updateCamera(deltaTime); 
            updateHUD();
            
            renderer.render(scene, camera);
        }

        // --- START ---
        init();
    </script>
</body>
</html>
